# Ruby
# Package your Ruby project.
# Add steps that install rails, analyze code, save build artifacts, deploy, and more:
# https://docs.microsoft.com/azure/devops/pipelines/languages/ruby

name: '$(SourceBranchName)-$(Build.SourceVersion) Build-$(Build.BuildId)'
trigger:
  batch: true
  branches:
    include:
      - develop

pr:
  autoCancel: true
  branches:
    include:
      - develop
      - feature/*

variables:
  application.name: 'et1'
  azure.subscription.endpoint: 'hmcts-pet'
  manual.branch.prefix: 'develop'

jobs:
  - job: BuildAndTestApplication
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: Docker@1
      displayName: login
      inputs:
        azureSubscriptionEndpoint: '$(azure.subscription.endpoint)'
        azureContainerRegistry: $(azure.container.registry)
        command: login
    - bash: |
        branch_name=$(echo $(Build.SourceBranchName) | tr '[:upper:]' '[:lower:]')
        repo_sha=$(git rev-parse --verify HEAD)
        docker_image_tag_sha=${repo_sha:0:7}
        echo "##vso[task.setvariable variable=DOCKER_TAG;isOutput=true]${branch_name}-${docker_image_tag_sha}"
      displayName: 'Get Docker Tag (non manual push)'
      name: 'getDockerTag2'
      condition: or(eq(variables['Build.SourceBranch'], 'refs/heads/develop'), ne(variables['Build.Reason'], 'Manual'))
    - bash: |
        branch_name=$(echo $(Build.SourceBranchName) | tr '[:upper:]' '[:lower:]')
        repo_sha=$(git rev-parse --verify HEAD)
        docker_image_tag_sha=${repo_sha:0:7}
        echo "##vso[task.setvariable variable=DOCKER_TAG;isOutput=true]$(manual.branch.prefix)-${branch_name}-${docker_image_tag_sha}"
      displayName: 'Get Docker Tag (manual push)'
      name: 'getDockerTag1'
      condition: and(ne(variables['Build.SourceBranch'], 'refs/heads/develop'), eq(variables['Build.Reason'], 'Manual'))
    - bash: |
        env
        echo "SourceBranchName is $(Build.SourceBranchName)"
        echo "1 is $GETDOCKERTAG1_DOCKER_TAG"
        echo "2 is $GETDOCKERTAG2_DOCKER_TAG"
        echo "combined is $GETDOCKERTAG1_DOCKER_TAG$GETDOCKERTAG2_DOCKER_TAG"
        echo "##vso[task.setvariable variable=DOCKER_TAG;isOutput=true]$GETDOCKERTAG1_DOCKER_TAG$GETDOCKERTAG2_DOCKER_TAG"
      name: 'getDockerTag'
    - task: Docker@1
      displayName: 'Build main image'
      inputs:
        imageName: '$(application.name):$(getDockerTag.DOCKER_TAG)'
        dockerfile: 'Dockerfile.production'
        arguments: '--build-arg APPVERSION=$(getDockerTag.DOCKER_TAG) --build-arg APP_BUILD_TAG=$(Build.SourceBranchName)-$(Build.SourceVersion) --build-arg APP_GIT_COMMIT=$(Build.SourceVersion)'
    - task: Docker@1
      displayName: 'Tag main image'
      inputs:
        azureSubscriptionEndpoint: '$(azure.subscription.endpoint)'
        azureContainerRegistry: $(azure.container.registry)
        command: 'Tag image'
        imageName: '$(application.name):$(getDockerTag.DOCKER_TAG)'
    - script: |
        mv .dockerignore .dockerignore.backup && \
        cp Dockerfile.test.dockerignore .dockerignore && \
        SOURCE_DOCKER_IMAGE="$(application.name):$(getDockerTag.DOCKER_TAG)" docker-compose -p $(Build.BuildId) -f docker-compose-test.yml run --rm test && \
        rm .dockerignore && \
        mv .dockerignore.backup .dockerignore
      displayName: 'Run tests in docker'
    - script: |
        docker-compose -p $(Build.BuildId) -f docker-compose-test.yml down --rmi local -v
      condition: always()
      displayName: Cleanup
    - task: Docker@1
      displayName: 'Push main image'
      inputs:
        azureSubscriptionEndpoint: '$(azure.subscription.endpoint)'
        azureContainerRegistry: $(azure.container.registry)
        command: 'Push an image'
        imageName: '$(application.name):$(getDockerTag.DOCKER_TAG)'
      condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/develop'), eq(variables['Build.Reason'], 'Manual')))
    - task: Docker@1
      displayName: logout
      inputs:
        command: logout
    - task: PublishBuildArtifacts@1
      condition: failed()
      inputs:
        pathToPublish: '$(Build.SourcesDirectory)/tmp/capybara'
        artifactName: screenshots
    - task: DownloadBuildArtifacts@0
      condition: failed()
      inputs:
        buildType: 'current'
        downloadType: 'single'
        artifactName: 'screenshots'
        downloadPath: '$(System.ArtifactsDirectory)'
        allowPartiallySucceededBuilds: true

#  - job: BuildAndPushImage
#    dependsOn: TestApplication
#    #condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
#    condition: succeeded()
#    pool:
#      vmImage: 'ubuntu-latest'
#    steps:
#    - task: Docker@1
#      displayName: login
#      inputs:
#        azureSubscriptionEndpoint: '$(azure.subscription.endpoint)'
#        azureContainerRegistry: $(azure.container.registry)
#        command: login
#

  # - job: ExtractAssets
  #   dependsOn: BuildAndPushImage
  #   condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
  #   pool:
  #     name: hmcts-pet
  #   variables:
  #     docker.tag: $[ dependencies.BuildAndPushImage.outputs['getDockerTag.DOCKER_TAG'] ]
  #   steps:

  #     - task: Docker@1
  #       displayName: 'Run an image'
  #       inputs:
  #         command: 'Run an image'
  #         imageName: '$(application.name):$(docker.tag)'
  #         containerName: 'ASSET_CONTAINER'

  #     - bash: |
  #         mkdir -p temp_assets
  #         docker cp ASSET_CONTAINER:/usr/src/app/public/assets ./temp_assets
  #         docker stop ASSET_CONTAINER
  #         cd temp_assets/assets
  #         docker rm ASSET_CONTAINER
  #       displayName: 'Get Assets'
  #       name: 'getAssets'

  #     - bash: |
  #         az login --service-principal -u $(ARM_CLIENT_ID) -p $(ARM_CLIENT_SECRET) --tenant $(ARM_TENANT_ID)
  #         az storage blob delete-batch -s assets --account-name $(azure.storage.account)
  #       displayName: 'Clean Up Blob'
  #       name: 'cleanUpBlob'

  #     - bash: |
  #         az login --service-principal -u $(ARM_CLIENT_ID) -p $(ARM_CLIENT_SECRET) --tenant $(ARM_TENANT_ID)
  #         cd temp_assets/assets
  #         az storage blob upload-batch -d assets --account-name $(azure.storage.account) -s .
  #       displayName: 'Copy Assets To Blob'
  #       name: 'copyToBlob'


#  - job: ManualBuildAndPushImage
#    dependsOn: TestApplication
#    condition: and(succeeded(), ne(variables['Build.SourceBranch'], 'refs/heads/develop'), eq(variables['Build.Reason'], 'Manual'))
#    pool:
#      vmImage: 'ubuntu-latest'
#    steps:
#    - bash: |
#        repo_sha=$(git rev-parse --verify HEAD)
#        docker_image_tag_sha=${repo_sha:0:7}
#        echo "##vso[task.setvariable variable=DOCKER_TAG;isOutput=true]$(manual.branch.prefix)-$(Build.SourceBranchName)-${docker_image_tag_sha}"
#      displayName: 'Get Docker Tag'
#      name: 'getDockerTag'
#
#    - task: Docker@1
#      displayName: login
#      inputs:
#        azureSubscriptionEndpoint: '$(azure.subscription.endpoint)'
#        azureContainerRegistry: $(azure.container.registry)
#        command: login
#
#    - task: Docker@1
#      displayName: 'Build an image'
#      inputs:
#        imageName: '$(application.name):$(getDockerTag.DOCKER_TAG)'
#        arguments: '--build-arg APPVERSION=$(getDockerTag.DOCKER_TAG) --build-arg APP_BUILD_TAG=$(Build.SourceBranchName)-$(Build.SourceVersion) --build-arg APP_GIT_COMMIT=$(Build.SourceVersion)'
#
#    - task: Docker@1
#      displayName: 'Tag image'
#      inputs:
#        azureSubscriptionEndpoint: '$(azure.subscription.endpoint)'
#        azureContainerRegistry: $(azure.container.registry)
#        command: 'Tag image'
#        imageName: '$(application.name):$(getDockerTag.DOCKER_TAG)'
#
#    - task: Docker@1
#      displayName: 'Push an image'
#      inputs:
#        azureSubscriptionEndpoint: '$(azure.subscription.endpoint)'
#        azureContainerRegistry: $(azure.container.registry)
#        command: 'Push an image'
#        imageName: '$(application.name):$(getDockerTag.DOCKER_TAG)'
#
#    - task: Docker@1
#      displayName: logout
#      inputs:
#        command: logout


  # - job: ManualExtractAssets
  #   dependsOn: ManualBuildAndPushImage
  #   pool:
  #     name: hmcts-pet
  #   variables:
  #     docker.tag: $[ dependencies.ManualBuildAndPushImage.outputs['getDockerTag.DOCKER_TAG'] ]
  #   steps:

  #     - task: Docker@1
  #       displayName: 'Run an image'
  #       inputs:
  #         command: 'Run an image'
  #         imageName: '$(application.name):$(docker.tag)'
  #         containerName: 'ASSET_CONTAINER'

  #     - bash: |
  #         mkdir -p temp_assets
  #         docker cp ASSET_CONTAINER:/usr/src/app/public/assets ./temp_assets
  #         docker stop ASSET_CONTAINER
  #         cd temp_assets/assets
  #         docker rm ASSET_CONTAINER
  #       displayName: 'Get Assets'
  #       name: 'getAssets'

  #     - bash: |
  #         az login --service-principal -u $(ARM_CLIENT_ID) -p $(ARM_CLIENT_SECRET) --tenant $(ARM_TENANT_ID)
  #         az storage blob delete-batch -s assets --account-name $(azure.storage.account)
  #       displayName: 'Clean Up Blob'
  #       name: 'cleanUpBlob'

  #     - bash: |
  #         az login --service-principal -u $(ARM_CLIENT_ID) -p $(ARM_CLIENT_SECRET) --tenant $(ARM_TENANT_ID)
  #         cd temp_assets/assets
  #         az storage blob upload-batch -d assets --account-name $(azure.storage.account) -s .
  #       displayName: 'Copy Assets To Blob'
  #       name: 'copyToBlob'
